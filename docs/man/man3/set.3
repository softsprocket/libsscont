.\" Process this file with
.\" groff -man -Tascii set.3
.\"
.TH SET 3 2014.11.01 "" "SoftSprocket libsscont"
.SH NAME
set_create set_get_item set_add_item set_add_items set_all_subsets set_get_item set_union set_intersection set_delete \- generic set operations in C
.SH SYNOPSIS
.nf
.B #include <softsprocket/containers.h>
.sp
.B set* set_create (size_t size, int (*equals) (void*, void*));
.br
.B ssize_t set_get_item_index (set* s, void* item);
.br
.B void* set_get_item (set* s, size_t pos);
.br
.B ssize_t set_add_item (set* s, void* item);
.br
.B ssize_t set_add_items (set* s, void** items, size_t size);
.br
.B set* set_all_subsets (set* s);
.br
.B set* set_union (set* s, set* other);
.br
.B set* set_intersection (set* s, set* other);
.br
.B void set_delete (set* s, void (*delete_item)(void*));
.fi
.sp
Link with \fI\-lsscont\fP.
.sp
.SH DESCRIPTION
These functions provide an interface to a fixed size set container and set operations.
.sp
.br 
set* set_create (size_t size, int (*equals) (void*, void*))  	
.in +4n
.br
size param - the number of pointers it will store.
.br
equals - a function that will be used to determine equality for the set. The set contains unique items based on this equality.
.br
returns - a pointer to a set or NULL if an error occurs
.in
.br
.sp
void set_delete (set* s, void (*delete_item)(void*))
.in +4n
.br		
s - the set to operate on
.br
delete_item - a function to be called on each item. If NULL the programmer must free item memory  		 
.in
.br
.sp
.nf
The structure that is returned by set_create: 
typedef struct {
	size_t size;			// total space available
	size_t count;			// current count
	void** data;			// pointer storage
	int (*equals) (void*, void*);	// saved equality function
} set;
.fi
.br
.sp
ssize_t set_get_item_index (set* s, void* item)
.br
.in +4n
s - a pointer to the set to be operated on
.br
item - the item whose index will be returned
.br
returns - the index of an item or -1 if none is found. 
.br
.in
.sp
ssize_t set_add_item (set* s, void* item)
.br
.in +4n
s - a pointer to the set to be operated on
.br
item - the item to add
.br
returns - the current count or -1 if an error occurs
.br
.in
.sp
ssize_t set_add_items (set* s, void** items, size_t size)
.br
.in +4n
s - a pointer to the set to be operated on
.br
items - the items to be added
.br
size - thenumber of items in the array
.br
returns - the current count or -1 if an error occurs
.br
.in
.sp
void* set_get_item (set* s, size_t pos)
.br
.in +4n
s - a pointer to the set to be operated on
.br
pos - the index of the item
.br
returns - the item at the index or NULL if an error occurs
.in
.sp
set* set_all_subsets (set* s)
.br
.in +4n
s - a pointer to the set to be operated on
.br
returns - a set of all the sets in the set passed as the param or NULL if there's an error. 
Memory for the power set should be reclaimed by calling set_delete with a function pointer that calls set_delete with a NULL function pointer.
i.e.
.nf
void set_deleter (void* v) {
	set_delete (v, NULL);
}
.fi
.in
.sp
set* set_union (set* s, set* other);
.br
.in +4n
s - a set to perform union on
.br
other - a set to perform union on
.br
returns - a set of the union of the two sets. Memory should be reclaimed on the return set
by calling set_delete with a NULL function pointer
.in
.sp
set* set_intersection (set* s, set* other);
.br
.in +4n
s - a set to perform intersection on
.br
other - a set to perform intersection on
.br
returns - a set of the intersection of the two sets. Memory should be reclaimed on the return set
by calling set_delete with a NULL function pointer
.in
.sp    
.sp
.nf
#include "debug_utils.h"
#include <stdio.h>
#include <stdlib.h>
#include <softsprocket/container.h>


int hash_table_test () {
	hash_table* ht = hash_table_create (10);
	if (ht == NULL) {
		PMSG ("hash_table_create: returned NULL");
		return EXIT_FAILURE;
	}

	if (ht->size != 10) {
		PDEC();
		fprintf (stderr, "hash_table_create initialization: ht->size %lu != 10\n", ht->size);
		return EXIT_FAILURE;
	}

	char* key_values[6][2] = {
		{ "red", "Roses are red" },
		{ "red", "Apples are red" },
		{ "red", "Books are read" },
		{ "blue", "The sky is blue" },
		{ "green", "Grass is green" },
		{ "green", "Avacadoes are green"}
	};

	for (int i = 0; i < 6; ++i) {
		hash_entry* he = hash_table_put (ht, key_values[i][0], key_values[i][1]);
		if (he == NULL) {
			PMSG ("hash_table_put: returned NULL");
			return EXIT_FAILURE;
		}
		
		if (strcmp (he->key, key_values[i][0]) != 0) {
			PDEC ();
			fprintf (stderr, "hash_table_put: hash_entry key %s != %s\n", he->key, key_values[i][0]);
			return EXIT_FAILURE;
		}

	}

	auto_array* keys = hash_table_keys (ht);
	if (keys->count != 6) {
		PDEC ();
		fprintf (stderr, "hash_table_keys count %lu != 6\n", keys->count);
		return EXIT_FAILURE;
	}

	auto_array_delete (keys, NULL);

	auto_array* reds = hash_table_get_all (ht, "red");
	if (reds == NULL) {
		PMSG ("hash_table_get_all: returned NULL");
		return EXIT_FAILURE;
	}

	if (reds->count != 3) {
		PDEC ();
		fprintf (stderr, "hash_table_get_all \"red\" count %lu != 3\n", reds->count);
		return EXIT_FAILURE;
	}

	for (int i = 0; i < reds->count; ++i) {
		char* s = auto_array_get(reds, i);
		if (strcmp (s, key_values[i][1]) != 0) {
			PDEC ();
			fprintf (stderr, "hash_table_get_all: %s != %s\n", s, key_values[i][1]);
			return EXIT_FAILURE;
		}
	}

	auto_array_delete (reds, NULL);

	char* blue_str = hash_table_get (ht, "blue");
	if (blue_str == NULL) {
		PMSG ("hash_table_get: returned NULL");
		return EXIT_FAILURE;
	}

	if (strcmp (blue_str, key_values[3][1]) != 0) {
		PDEC ();
		fprintf (stderr, "hash_table_get: %s != %s\n", blue_str, key_values[3][1]);
		return EXIT_FAILURE;
	}

	blue_str = hash_table_remove (ht, "blue");
	if (blue_str == NULL) {
		PMSG ("hash_table_remove: returned NULL");
		return EXIT_FAILURE;
	}

	if (strcmp (blue_str, key_values[3][1]) != 0) {
		PDEC ();
		fprintf (stderr, "hash_table_remove: %s != %s\n", blue_str, key_values[3][1]);
		return EXIT_FAILURE;
	}

	blue_str = hash_table_get (ht, "blue");
	if (blue_str != NULL) {
		PDEC ();
		fprintf (stderr, "hash_table_remove:  get blue returned %s\n", blue_str);
		return EXIT_FAILURE;
	}

	hash_table_delete (ht, NULL);

	printf ("hash_table tests pass\n");

	return EXIT_SUCCESS;
}

int equals (void* this, void* that) {
	int* l = this;
	int* r = that;

	return *l == *r;
}

void dset (void* v) {
	set_delete (v, NULL);
}
.fi
.SH BUGS
No known bugs.
.SH AUTHOR
Greg Martin <greg@softsprocket.com>
.SH "SEE ALSO"
.BR auto_array (3),
.BR hash_table (3),
.BR auto_string (3)


